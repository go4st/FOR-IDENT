package de.hswt.fi.fileimport.service.txt;

import de.hswt.fi.common.FileUtil;
import de.hswt.fi.fileimport.service.api.FileBasedFeatureContentImporter;
import de.hswt.fi.model.Feature;
import de.hswt.fi.model.FeatureSet;
import de.hswt.fi.model.Peak;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

@Component
@Scope("prototype")
public class SciexTxtFeatureContentImporter implements FileBasedFeatureContentImporter {

	/**
	 * Fragile, naive implementation to parse a text file generated by the sciex
	 * software into a {@link FeatureSet}. The alogrithm first remove all blank
	 * lines, and then conactenates groups of six lines. Each group represents a
	 * Feature.
	 * 
	 * @param contentPath
	 *            the path to the txt file
	 * @return a FeatureSet or null if the file can not be parsed, which is most
	 *         likely...
	 */
	@Override
	public FeatureSet importFromFile(Path contentPath) {

		List<String> lines = FileUtil.readAllLines(contentPath);
		lines = lines.stream().filter(line -> !line.isEmpty()).collect(Collectors.toList());

		StringBuilder stringBuilder = new StringBuilder();
		List<Feature> features = new ArrayList<>();

		/*
		 * Read lines until end token and parse a feature
		 */
		for (String line : lines) {

			if (!line.equals("//")) {
				stringBuilder.append(line);
				stringBuilder.append("\n");
			} else {
				Feature feature = getFeature(stringBuilder.toString());
				if (feature != null) {
					features.add(feature);
				}
				stringBuilder.setLength(0);
			}
		}

		return new FeatureSet(contentPath, features);
	}

	@Override
	public boolean canHandle(Path path) {
		return path.getFileName().toString().endsWith(".txt");
	}

	private Feature getFeature(String featureString) {

		List<String> tokens = Arrays.asList(featureString.split("\n"));
		Iterator<String> iterator = tokens.iterator();

		String name = getStringValue(iterator.next());
		Double retentionTime = getDoubleValue(iterator.next());
		Double precursorMass = getDoubleValue(iterator.next());
		String formula = getStringValue(iterator.next());
		if (formula.contains("No data") || formula.contains("Error")
				|| formula.contains("No formula")) {
			formula = null;
		}

		// Check if peaks are present
		List<Peak> peaks = new ArrayList<>();
		while (iterator.hasNext()) {

			String next = iterator.next();

			if (next.contains("N/A")) {
				break;
			}

			// Peak values are seperated by a blank char... Hopefully...
			String[] peaksString = next.split(" ");

			int i = 0;
			while (i < peaksString.length) {
				Peak peak = new Peak(Double.parseDouble(peaksString[i]),
						Double.parseDouble(peaksString[i + 1]));
				peaks.add(peak);
				i += 2;
			}
		}

		return new Feature.Builder(name, precursorMass)
				.withRetentionTime(retentionTime)
				.withNeutralFormula(formula)
				.withPeaks(peaks)
				.build();
	}

	private String getStringValue(String line) {
		return line.split(":")[1].trim();
	}

	private Double getDoubleValue(String line) {
		return Double.parseDouble(line.split(":")[1]);
	}

}
